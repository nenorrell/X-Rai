package generator

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/nenorrell/xrai/internal/schema"
)

func (g *Generator) generateLLMsTxt(db *schema.Database) error {
	var sb strings.Builder

	// Header
	sb.WriteString("# Database Schema: ")
	sb.WriteString(db.Name)
	sb.WriteString("\n\n")

	sb.WriteString("> This file is auto-generated by xrai. It provides LLM-optimized database context.\n")
	sb.WriteString("> Read this file first, then drill into specific table files as needed.\n\n")

	// Quick stats
	sb.WriteString("## Overview\n\n")
	sb.WriteString(fmt.Sprintf("- **Database**: %s (%s %s)\n", db.Name, db.Engine, db.Version))
	sb.WriteString(fmt.Sprintf("- **Schemas**: %s\n", strings.Join(db.Schemas, ", ")))
	sb.WriteString(fmt.Sprintf("- **Tables**: %d\n", len(db.Tables)))
	if len(db.Views) > 0 {
		sb.WriteString(fmt.Sprintf("- **Views**: %d\n", len(db.Views)))
	}
	if len(db.Enums) > 0 {
		sb.WriteString(fmt.Sprintf("- **Enums**: %d\n", len(db.Enums)))
	}
	sb.WriteString("\n")

	// How to use this schema
	sb.WriteString("## How to Use This Schema\n\n")
	sb.WriteString("This directory contains a complete database schema snapshot. To answer user questions:\n\n")
	sb.WriteString("1. **Start here** - This file contains table summaries and relationships\n")
	sb.WriteString("2. **Need column details?** - Read `tables/<table_name>/table.columns.toon`\n")
	sb.WriteString("3. **Need relationships?** - Read `tables/<table_name>/table.relations.toon`\n")
	sb.WriteString("4. **Need constraints/indexes?** - Read the respective table files\n")
	sb.WriteString("5. **Need full relationship graph?** - Read `db.relationships.toon`\n\n")

	// File structure reference
	sb.WriteString("## File Structure\n\n")
	sb.WriteString("```\n")
	sb.WriteString(".xrai/\n")
	sb.WriteString("├── llms.txt                    # This file (start here)\n")
	sb.WriteString("├── db.index.toon               # All tables with metadata\n")
	sb.WriteString("├── db.relationships.toon       # Foreign key graph\n")
	sb.WriteString("├── db.domains.toon             # Logical groupings\n")
	sb.WriteString("├── tables/<name>/\n")
	sb.WriteString("│   ├── table.structure.toon    # Basic info, primary key\n")
	sb.WriteString("│   ├── table.columns.toon      # Column definitions\n")
	sb.WriteString("│   ├── table.relations.toon    # Foreign keys in/out\n")
	sb.WriteString("│   ├── table.indexes.toon      # Index definitions\n")
	sb.WriteString("│   └── table.constraints.toon  # Constraints\n")
	if len(db.Enums) > 0 {
		sb.WriteString("├── enums/<name>.toon           # Enum type values\n")
	}
	if len(db.Routines) > 0 {
		sb.WriteString("├── routines/functions/         # Database functions\n")
	}
	sb.WriteString("└── xrai.manifest.toon          # Generation metadata\n")
	sb.WriteString("```\n\n")

	// Table summaries - the core content
	sb.WriteString("## Tables\n\n")

	// Group by tags for better organization
	coreTables := make([]*schema.Table, 0)
	junctionTables := make([]*schema.Table, 0)
	lookupTables := make([]*schema.Table, 0)
	otherTables := make([]*schema.Table, 0)

	for _, t := range db.Tables {
		tagged := false
		for _, tag := range t.Tags {
			switch tag {
			case "core":
				coreTables = append(coreTables, t)
				tagged = true
			case "junction":
				junctionTables = append(junctionTables, t)
				tagged = true
			case "lookup":
				lookupTables = append(lookupTables, t)
				tagged = true
			}
			if tagged {
				break
			}
		}
		if !tagged {
			otherTables = append(otherTables, t)
		}
	}

	// Write core tables first (most important)
	if len(coreTables) > 0 {
		sb.WriteString("### Core Tables\n\n")
		sb.WriteString("Central entities that other tables reference:\n\n")
		for _, t := range coreTables {
			writeTableSummary(&sb, t, g.cfg.RedactComments)
		}
	}

	// Other tables (main content)
	if len(otherTables) > 0 {
		if len(coreTables) > 0 {
			sb.WriteString("### Other Tables\n\n")
		}
		for _, t := range otherTables {
			writeTableSummary(&sb, t, g.cfg.RedactComments)
		}
	}

	// Junction tables
	if len(junctionTables) > 0 {
		sb.WriteString("### Junction Tables (Many-to-Many)\n\n")
		for _, t := range junctionTables {
			writeTableSummary(&sb, t, g.cfg.RedactComments)
		}
	}

	// Lookup tables
	if len(lookupTables) > 0 {
		sb.WriteString("### Lookup/Reference Tables\n\n")
		for _, t := range lookupTables {
			writeTableSummary(&sb, t, g.cfg.RedactComments)
		}
	}

	// Key relationships summary
	sb.WriteString("## Key Relationships\n\n")
	writeRelationshipsSummary(&sb, db.Tables)

	// Enums if present
	if len(db.Enums) > 0 {
		sb.WriteString("## Enums\n\n")
		for _, e := range db.Enums {
			sb.WriteString(fmt.Sprintf("- **%s**: %s\n", e.EnumName, strings.Join(e.Values, ", ")))
		}
		sb.WriteString("\n")
	}

	return g.writeFile(filepath.Join(g.outputDir, "llms.txt"), sb.String())
}

func writeTableSummary(sb *strings.Builder, t *schema.Table, redactComments bool) {
	sb.WriteString(fmt.Sprintf("**%s**", t.TableName))

	// Add row count if available
	if t.RowCountEstimate != nil && *t.RowCountEstimate > 0 {
		sb.WriteString(fmt.Sprintf(" (~%d rows)", *t.RowCountEstimate))
	}
	sb.WriteString("\n")

	// Add description if available
	if !redactComments && t.Comment != "" {
		sb.WriteString(fmt.Sprintf("  %s\n", truncateDescription(t.Comment, 150)))
	}

	// Primary key
	pk := getPrimaryKeyColumns(t)
	if len(pk) > 0 {
		sb.WriteString(fmt.Sprintf("  PK: %s\n", strings.Join(pk, ", ")))
	}

	// Key columns (abbreviated)
	cols := getKeyColumnsSummary(t)
	if cols != "" {
		sb.WriteString(fmt.Sprintf("  Columns: %s\n", cols))
	}

	// Relationships summary
	if len(t.OutgoingForeignKeys) > 0 {
		refs := make([]string, 0, len(t.OutgoingForeignKeys))
		for _, fk := range t.OutgoingForeignKeys {
			refs = append(refs, fk.ToTable)
		}
		sb.WriteString(fmt.Sprintf("  References: %s\n", strings.Join(refs, ", ")))
	}

	if len(t.IncomingForeignKeys) > 0 {
		refs := make([]string, 0, len(t.IncomingForeignKeys))
		for _, fk := range t.IncomingForeignKeys {
			refs = append(refs, fk.FromTable)
		}
		sb.WriteString(fmt.Sprintf("  Referenced by: %s\n", strings.Join(refs, ", ")))
	}

	sb.WriteString("\n")
}

func getKeyColumnsSummary(t *schema.Table) string {
	if len(t.Columns) == 0 {
		return ""
	}

	// Get PK columns to exclude
	pkCols := make(map[string]bool)
	for _, col := range getPrimaryKeyColumns(t) {
		pkCols[col] = true
	}

	// Get FK columns
	fkCols := make(map[string]bool)
	for _, fk := range t.OutgoingForeignKeys {
		for _, col := range fk.FromColumns {
			fkCols[col] = true
		}
	}

	// Collect non-PK columns, prioritizing important ones
	var important []string
	var other []string

	for _, col := range t.Columns {
		if pkCols[col.ColumnName] {
			continue
		}

		summary := col.ColumnName
		if fkCols[col.ColumnName] {
			summary += " (FK)"
		}

		// Prioritize certain column patterns
		name := strings.ToLower(col.ColumnName)
		if strings.Contains(name, "name") || strings.Contains(name, "title") ||
			strings.Contains(name, "email") || strings.Contains(name, "status") ||
			strings.Contains(name, "type") || fkCols[col.ColumnName] {
			important = append(important, summary)
		} else {
			other = append(other, summary)
		}
	}

	// Combine with limit
	all := append(important, other...)
	if len(all) > 8 {
		return strings.Join(all[:8], ", ") + fmt.Sprintf(", ... (+%d more)", len(all)-8)
	}
	return strings.Join(all, ", ")
}

func writeRelationshipsSummary(sb *strings.Builder, tables []*schema.Table) {
	// Find tables with most connections
	type tableConns struct {
		name     string
		incoming int
		outgoing int
	}

	conns := make([]tableConns, 0, len(tables))
	for _, t := range tables {
		if len(t.IncomingForeignKeys) > 0 || len(t.OutgoingForeignKeys) > 0 {
			conns = append(conns, tableConns{
				name:     t.TableName,
				incoming: len(t.IncomingForeignKeys),
				outgoing: len(t.OutgoingForeignKeys),
			})
		}
	}

	// Sort by total connections
	sort.Slice(conns, func(i, j int) bool {
		return (conns[i].incoming + conns[i].outgoing) > (conns[j].incoming + conns[j].outgoing)
	})

	// Show top connected tables
	sb.WriteString("Most connected tables:\n")
	limit := 10
	if len(conns) < limit {
		limit = len(conns)
	}
	for i := 0; i < limit; i++ {
		c := conns[i]
		sb.WriteString(fmt.Sprintf("- %s: %d incoming, %d outgoing FKs\n", c.name, c.incoming, c.outgoing))
	}
	sb.WriteString("\n")
}

func (g *Generator) writeFile(path string, content string) error {
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory %s: %w", dir, err)
	}
	return os.WriteFile(path, []byte(content), 0644)
}
